# How\_to\_Test\_AT24C256\_EEPROM\_via\_I2C\_on\_STM32

This implementation guide and provided code follow a project structure consistent with files auto-generated by STM32CubeMX.

***

## Understanding AT24C256 I¬≤C Address (for STM32 HAL)

The AT24C256 EEPROM uses a 7-bit I¬≤C address, and its value depends on how the three hardware address pins (A2, A1, A0) are wired.

***

## üìò Address Table

| A2 | A1 | A0 | 7-bit Address | 8-bit Write Addr | 8-bit Read Addr |
| -- | -- | -- | ------------- | ---------------- | --------------- |
| 0  | 0  | 0  | `0x50`        | `0xA0`           | `0xA1`          |
| 0  | 0  | 1  | `0x51`        | `0xA2`           | `0xA3`          |
| 0  | 1  | 0  | `0x52`        | `0xA4`           | `0xA5`          |
| ‚Ä¶  | ‚Ä¶  | ‚Ä¶  | ‚Ä¶             | ‚Ä¶                | ‚Ä¶               |

* The 7-bit address range is `0x50`‚Äì`0x57`.
* The 8-bit address range (old datasheet format) is `0xA0`‚Äì`0xAE`.

***

## How STM32 HAL Interprets the Address

STM32 HAL functions such as:

```
HAL_StatusTypeDef HAL_I2C_Mem_Write(
  I2C_HandleTypeDef *hi2c,   // I2C handle, e.g. &hi2c1
  uint16_t DevAddress,       // I2C device address (7-bit shifted left by 1)
  uint16_t MemAddress,       // Memory address inside the device
  uint16_t MemAddSize,       // Internal address size: I2C_MEMADD_SIZE_8BIT or I2C_MEMADD_SIZE_16BIT
  uint8_t *pData,            // Pointer to data buffer
  uint16_t Size,             // Number of bytes to write
  uint32_t Timeout           // Timeout in ms
);
```

The DevAddress argument should be the 7-bit address shifted left by 1, which is A0 in our design:

```c
// Correct for AT24C256 with A0~A2 = GND
#define EEPROM_ADDR   (0x50 << 1)   // = 0xA0
```

***

## Use STM32 HAL for EEPROM tests

### Create New Files

{% stepper %}
{% step %}
Right-click `Core/Src` ‚Üí New ‚Üí Source File ‚Üí name it: `eeprom_test.c`
{% endstep %}

{% step %}
Right-click `Core/Inc` ‚Üí New ‚Üí Header File ‚Üí name it: `eeprom_test.h`
{% endstep %}

{% step %}
In `eeprom_test.c`, include the header file:

```c
#include "eeprom_test.h"
```
{% endstep %}
{% endstepper %}

### Global variables for debugging

In the `eeprom_test.h` header file, define the EEPROM address and declare essential functions to write and read data from EEPROM. Two global variables are defined for debugging:

```c
uint8_t writeData[] = "Hello EEPROM!";
uint8_t readData[32] = {0};
```

### Header file: eeprom\_test.h

```c
#ifndef INC_EEPROM_TEST_H_
#define INC_EEPROM_TEST_H_

/* -------------------------------------------------------------------------- */
/*                          EEPROM I2C configuration                          */
/* -------------------------------------------------------------------------- */
#define EEPROM_I2C                hi2c1              // I2C handle (defined in main.c)
#define EEPROM_ADDRESS            0xA0              // AT24C256 address (A2‚ÄìA0 = GND)
#define EEPROM_PAGE_SIZE          64                // 64 bytes per page
#define EEPROM_WRITE_DELAY_MS     10                // typical write cycle time

void EEPROM_Test(void);
HAL_StatusTypeDef EEPROM_Read(uint16_t MemAddress, uint8_t *pData, uint16_t Size);
HAL_StatusTypeDef EEPROM_Write(uint16_t MemAddress, uint8_t *pData, uint16_t Size);

#endif /* INC_EEPROM_TEST_H_ */
```

### Source file: eeprom\_test.c

In the following C file, STM32 HAL is used to write data to EEPROM (AT24C256) and read it back for verification.

```c
/**
 ******************************************************************************
 * @file    eeprom_test.c
 * @brief   AT24C256 EEPROM test and driver example for STM32F405
 * @description
 *   This file demonstrates how to initialize I2C, write data to an external
 *   EEPROM (AT24C256), and read it back for verification using STM32 HAL.
 ******************************************************************************
 */

#include "main.h"
#include "eeprom_test.h"
#include <string.h>
#include <stdio.h>

extern I2C_HandleTypeDef hi2c1;                     // imported from main.c

/* -------------------------------------------------------------------------- */
/*                          EEPROM driver functions                           */
/* -------------------------------------------------------------------------- */

/**
 * @brief  Write a block of data to the EEPROM
 * @param  MemAddress: 16-bit memory address in EEPROM
 * @param  pData: pointer to data buffer
 * @param  Size: number of bytes to write
 * @retval HAL status
 */
HAL_StatusTypeDef EEPROM_Write(uint16_t MemAddress, uint8_t *pData, uint16_t Size)
{
    /* Note:
       AT24C256 uses 16-bit memory addressing.
       Ensure write size does not cross a 64-byte page boundary.
    */
    HAL_StatusTypeDef status;

    status = HAL_I2C_Mem_Write(&EEPROM_I2C,
                               EEPROM_ADDRESS,
                               MemAddress,
                               I2C_MEMADD_SIZE_16BIT,
                               pData,
                               Size,
                               100);

    /* Wait for internal write cycle */
    HAL_Delay(EEPROM_WRITE_DELAY_MS);
    return status;
}

/**
 * @brief  Read a block of data from the EEPROM
 * @param  MemAddress: 16-bit memory address in EEPROM
 * @param  pData: pointer to buffer to store read data
 * @param  Size: number of bytes to read
 * @retval HAL status
 */
HAL_StatusTypeDef EEPROM_Read(uint16_t MemAddress, uint8_t *pData, uint16_t Size)
{
    return HAL_I2C_Mem_Read(&EEPROM_I2C,
                            EEPROM_ADDRESS,
                            MemAddress,
                            I2C_MEMADD_SIZE_16BIT,
                            pData,
                            Size,
                            100);
}

/* -------------------------------------------------------------------------- */
/*                              Test function                                 */
/* -------------------------------------------------------------------------- */

/**
 * @brief  EEPROM functional test
 * @note   Write a test string to address 0x0000 and read it back.
 */
uint8_t writeData[] = "Hello EEPROM!";
uint8_t readData[32] = {0};

void EEPROM_Test(void)
{
    /* -------------------- Write test -------------------- */
    printf("EEPROM Write Start...\r\n");
    if (EEPROM_Write(0x0000, writeData, strlen((char*)writeData)) == HAL_OK)
        printf("EEPROM Write Done.\r\n");
    else
        printf("EEPROM Write Error!\r\n");

    /* -------------------- Read test --------------------- */
    printf("EEPROM Read Start...\r\n");
    if (EEPROM_Read(0x0000, readData, strlen((char*)writeData)) == HAL_OK)
    {
        printf("EEPROM Read Done.\r\n");
        printf("Read Data: %s\r\n", readData);
    }
    else
    {
        printf("EEPROM Read Error!\r\n");
    }
}

/*  Key notes
- AT24C256 uses 16-bit addressing.
- Each page = 64 bytes, do not cross page boundary in one write.
- EEPROM_ADDRESS may vary depending on hardware wiring of A0~A2.
- Always include a delay (~10 ms) after writing.
- Confirm I2C lines have proper pull-ups and no bus contention.
*/
```

***

## Debug mode in STM32IDE

Call the function `EEPROM_Test` in the default task in FreeRTOS.

* Include "eeprom\_test.h" in `main.c`.
* Add a line in `default_task` to call `EEPROM_Test()`.

Enter Debug Mode:

{% stepper %}
{% step %}
Click the üêû Debug icon or press fn+F11 to start debugging.
{% endstep %}

{% step %}
STM32CubeIDE will:

* Build and flash your firmware
* Automatically open the Debug Perspective
{% endstep %}

{% step %}
The program will pause at `main()` by default.&#x20;
{% endstep %}

{% step %}
Press fn+F8 to resume debugging.
{% endstep %}
{% endstepper %}

***

## Viewing Global Variables

* Go to Window ‚Üí Show View ‚Üí Live Expressions
* Add variable names manually (e.g., `readData`).
* Values will refresh automatically in real time.

From the Live Expressions window, you can confirm that the string "Hello EEPROM!" has been correctly written to EEPROM.

***

## Wrap-Up and Future Work

* Configured I¬≤C communication and verified basic EEPROM read/write functionality.
* This setup enables persistent storage of application parameters.

Next steps:

* Implement UART communication for PC-side debugging and GUI interaction.
* Use EEPROM for parameter initialization, runtime updates, and configuration storage.
