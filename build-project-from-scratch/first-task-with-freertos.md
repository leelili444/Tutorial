# First task with FreeRTOS

When we enable the FreeRTOS, CMSIS-RTOS V2 is set. Its full name is 'Cortex Microcontroller Software Interface Standard - Real-Time Operating System, Version 2'.

It is a standardized API (Application Programming Interface) defined by ARM to provide a vendor-independent abstraction layer for RTOS kernels running on Cortex-M microcontrollers (like the STM32).

## Green LED Blinking with FreeRTOS

Here we set up the first task in FreeRTOS 'Green LED  Blinking with FreeRTOS' using the  `defaultTask` generated by STM32CubeIDE.

The GPIO pin connected to the green LED has been defined as:
~~~
#define LED_Green_Pin GPIO_PIN_3
#define LED_Green_GPIO_Port GPIOA
~~~

## Understanding the FreeRTOS Task Execution Flow

Before implementing the blinking logic, it's vital to understand how FreeRTOS manages the **`defaultTask`** execution:

1.  **Task Creation:** 
   In the main function, the `defaultTask` is created via `osThreadNew()`, linking it to its start function, **`StartDefaultTask`** and task attributes structure **`defaultTask_attributes`**.
   ~~~
     defaultTaskHandle = osThreadNew(StartDefaultTask, NULL, &defaultTask_attributes);
   ~~~
2.  **Scheduler Start:**   
   Calling `osKernelStart()` transfers control to the **FreeRTOS kernel**. The scheduler then executes the highest-priority ready task (our `defaultTask`).
3.  **The Infinite Loop:** The code runs inside an essential **`for (;;)`** (infinite) loop. An RTOS task must never exit its function.
~~~
void StartDefaultTask(void *argument)
{
  /* USER CODE BEGIN 5 */
  /* Infinite loop */
  for(;;)
  {
    osDelay(1);
  }
  /* USER CODE END 5 */
}
~~~
4. **osDelay()**   
   When the task executes **`osDelay(500)`**:
    * The task is immediately moved from the **Running** state to the **Blocked** state for 500 milliseconds.
    * The **CPU is not halted**. The scheduler yields the CPU, checking for any other tasks to run. If there are none, the CPU enters a low-power **Idle** state.
    * After 500 milliseconds, the task is moved back to the **Ready** state, and the scheduler allows the CPU to resume execution from the line immediately following the `osDelay(500)` call.

This non-blocking delay is crucial for RTOS, ensuring the CPU isn't wasted while a task waits for time to pass.

## Step 3: Implement the Alternating Blink Logic

The **`StartDefaultTask`** function is in `main.c`, and place the following logic inside its infinite for (;;) loop. Contents within the USER CODE BEGIN and END sections will not change when you generate the code more times.


~~~
void StartDefaultTask(void *argument)
{
  /* USER CODE BEGIN 5 */
	ICM42688P_Init();
	uint8_t msg[] = "hello world\r\n";
  /* Infinite loop */
  for(;;)
  {
	  HAL_GPIO_TogglePin(GPIOA, LED_Green_Pin);
	  HAL_UART_Transmit(&huart1, msg, sizeof(msg) - 1, 100);
	  osDelay(200);

  }
  /* USER CODE END 5 */
}

~~~
## Step 4: Compile and Flash

This final step transfers your compiled FreeRTOS application onto the STM32 microcontroller.

1.  **Save** all files in your project.
2.  **Build** your project by clicking the **Project** menu -> **Build Project** (or use the hammer icon in the toolbar).
    * _Wait for the build process to complete successfully without errors._
3.  **Flash** the compiled code to your STM32 development board by clicking the **Run** menu -> **Run** or **Debug** (for flashing and starting execution). ST-Link needs to be connected. IDE will detect the ST-Link and set up for you.


Upon successful flashing, the green LED will immediately begin alternating their state every 200 **milliseconds**, confirming the `defaultTask` is running correctly.

Next time we will set up timers and run periodically with predefined frequency.